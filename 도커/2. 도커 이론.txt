[ 도커 ]
* 도커는 일반 개인용 컴퓨터에 설치하지 못한다.
* wsl(windows subsystem for linux, 윈도우 상에서 리눅스를 사용할 수 있도록 도와주는 도구)을 통해
리눅스를 사용할 수 있게 만들어서 도커 프로그램을 설치하여 사용한다.

* 도커를 삭제할땐, 컨테이너를 먼저 삭제 한 뒤, 참조하는 이미지를 삭제한다.

* $ : 변수
* $() : 해당 명령을 먼저 실행하고, 그 결과 값을 사용

애플리케이션 실행에 필요한 환경을 하나의 이미지로 묶어서 만들어두고,
해당 이미지를 이용해서 컨테이너를 만들어 애플리케이션을 실행하는 방식
-> 코드, 런타임, 시스템 도구, 라이브러리 등 필요

1. 기존 방식 vs 도커 방식
1) 기존 방식
mysql 설치
mysql 실행

2) 도커 방식
mysql 이미지 준비
mysql 컨테이너 만들어 실행 = 프로그램 실행

2. 도커의 장점
1) 격리 환경 제공 - 독립된 실행 환경을 제공 (컨테이너 기반의 오픈 소스 가상 플랫폼)
2) 애플리케이션을 신속하게 실행 (구축, 테스트, 배포하는 과정)

3. 도커의 컴포넌트
1) Docker Engine
- Docker Image 생성
- Docker Container 생성
- Docker 명령어 실행
- Dockerfile을 이용한 Docker Image 생성

2) Docker Registry
- Docker Image 공개 및 공유
- Docker Image 공유 서비스(각종 Docker Image 들이 공개되어있는 사이트) : Docker Hub

3) Docker Compose
- 애플리케이션 실행 환경을 구성하는 Container를 실행하기 위한 툴
- 애플리케이션 서비스를 구성하기 위해 YAML 형식으로 정의
  
4) Docker Swarm
- Docker Host들을 클러스터로 구축해서 관리할 수 있는 오케스트레이션 도구
- 쿠버네티스가 사실상 Docker Swarm을 대체하였음

* 클러스터   : 컨테이너 형태의 애플리케이션을 호스팅하는 노드들로 이루어진 집합
* 쿠버네티스 : 애플리케이션이 구동되는 환경을 감싸 실행할 수 있도록 하는 격리 기술 
- 쿠버네티스를 배포하면 클러스터를 얻는다. (쿠버네티스 실행 = 클러스터 실행)
* 오케스트레이션 : 여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위

* 한개의 컨테이너를 구동시킬때는 도커 사용,
다수의 컨테이너를 구동하여 환경을 관리 및 조율할 때는 쿠버네티스를 사용한다.

4. Docker 동작 구조
1) Image를 내려 받는 경우
Docker Hub > Image pull > Create Container > Run Container
                  --------------------------------------------------- > Docker Engine이 담당
도커허브에서  이미지 내려 받고  컨테이너를 만들어  실행 

2) Image를 만드는 경우
Dockerfile > Make Image > Create Container > Run Container
------------------------------------------------------------------- > Docker Engine이 담당
도커파일에서 이미지를 만들고 컨테이너를 만들어 실행

5. Docker 활용
1) Docker Image는 하나만 있으면 된다. (애플리케이션 당)
2) Docker Container는 여러 개를 만들 수 있다.
3) Docker Container는 일회용이다.
4) 기능 추가나 변경이 필요하면 Container를 수정하지 않고, Image를 수정한 뒤 Container를 다시 만든다.

6. docker image, container 리스트 확인 방법
$ docker system df -v : 도커 전체 내용 확인
$ docker image ls : 도커 이미지 리스트 출력
$ docker container ls : 도커 컨테이너 리스트 출력 (실행 중인 컨테이너만 확인)
$ docker system df | grep -i 'container' : 전체 내용 중 'container'만 출력

7. disk mount (bind mount)
호스트 컴퓨터의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 연결하는 기능
양뱡향 접근 및 수정이 가능 (호스트 디렉터리, 컨테이너 디렉터리 연결 시스템)

$ docker info | grep -i 'docker root dir'
Docker Root Dir : /var/lib/docker 
루트 디렉터리 내용 출력 > 해당 디렉터리가 꽉 차면 오류가 발생해 하드디스크로 용량을 추가해야 함


[ 도커 이미지 ]
도커 이미지는 docker hub로부터 내려받는다.
도커에서 내려받는건 이미지 밖에 없기 때문에 $ docker "image" pull에서 image 생략이 가능하다.

** 이미지 명령 규칙
docker.io/library/tomcat:latest
레파지토리 경로 / 이미지 이름 : 태그

** pull을 여러번 하는 이유는,
하나의 이미지 당 여러개의 레이어를 가지고 있어 여러번 pull이 실행됨

** 이미지의 태그 없으면 디폴트 값 : latest

$ docker search '이미지 이름'
원하는 이미지 검색하기
** official에 [ok]가 붙어있는 이미지가 공식 이미지임

$ docker image pull '이미지 이름'
이미지 내려받기
- 특정 태그 없이 입력하면 '가장 최근 버전' 이미지를 불러온다.
- 특정 레파지토리 지정 없이 입력하면 'docker.io/library/' 레파지토리의 이미지를 불러온다.
- image 생략 가능

$ docker image inspect '이미지 이름'
이미지 상세정보 보기

$ docker images / docker image ls
이미지 목록 보기

$ docker image tag '원래 별명(tomcat)' '새로운 별명(mytomcat)'
이미지 별명 추가하기 (이미지가 하나 더 붙음)

$ docker image rm '이미지 이름'
이미지 삭제하기
** 컨테이너가 참조하고 있는 이미지의 경우엔 삭제가 불가능함
** 컨테이너 자체를 먼저 삭제하고, 나중에 참조하고 있는 이미지를 삭제해야 함
** 축약 버전 : $ docker rmi '이미지 이름'

$ docker image rm $(docker images -aq)
모든 이미지 삭제하기


[ 도커 컨테이너 ]
* -a : 모든

$ docker container ls -a (= $ docker ps -a)
모든 컨테이너 목록 보기 (-a를 붙이지 않으면 실행중이지 않은 컨테이너는 보이지 않음)
* status에 up이 있으면, 현재 실행 중인 상태

$ docker container rm $(docker ps -aq)
현재 있는 모든 컨테이너들을 삭제

$ docker ps
현재 컨테이너 리스트 확인

$ docker container create '이미지 이름'
특정 이미지를 이용해 컨테이너를 만든다. (이때, 이미지 먼저 내려 받은 상태여야함)

$ docker container create --name '컨테이너 이름' '이미지 이름'
특정 이미지를 이용해 컨테이너를 만들때 옵션(name)을 지정하여 만든다.

$ docker container start '컨테이너 이름'
원하는 컨테이너 실행

$ docker container stop '컨테이너 이름'
실행중인 컨테이너 중단

$ cd '컨테이너 경로'
특정 컨테이너 안으로 이동
ex) cd /usr/share/nginx/html


[ 도커 run ]
$ docker container run --name '컨테이너이름' -d '내려받고자 하는 이미지'
ex) docker container run --name nginx-container -d nginx
(-d 와 --name 순서는 상관 없음)
이미지 내려 받고
컨테이너 만들고
컨테이너 실행까지
-------------
한 번에 해주는 명령

* -d : 프로그램 실행 후 다른 작업을 하고 싶을때 사용
(붙이지 않으면 실행 후 더이상 작업이 불가해 강제 종료 해야 함)

[ 도커의 포트포워딩 ]
* 컨테이너 포트를 열기 위한 호스트 포트 번호를 지정해줘야 함
* 빠른 동작 테스트를 위해 추천하는 방법은 httpd, nginx

* user → server → container (총 2번의 포트 포워딩이 필요함)
  호스트  게스트    컨테이너

1) 호스트와 게스트의 포트 포워딩
virtual box > 가상 서버 실행 종료 > 설정> 네트워크를 통해 호스트와 게스트의 포트 포워딩을 진행

2) 게스트와 컨테이너의 포트 포워딩
mobaxterm > 게스트와 container의 포트 포워딩을 진행
ex) docker run -d --name httpd-container -p 9000:80 httpd

3) localhost:포트 번호를 인터넷 창에 연결하여 체크
ex) 192.168.56.1:9000을 입력하여 체크

* -p : 포트 연결 옵션
$ docker run -d --name httpd-container -p 9000:80 httpd
도커 run을 통해 이미지 내려받기 / 컨테이너 만들기 / 컨테이너 실행 시 포트 포워딩도 함께 해줌

[ 도커 컨테이너 내용 수정 및 복사(데이터 주고 받기) ]

$ docker exec -it '컨테이너 이름 (nginx-container1)' bash
컨테이너 내부 접속하기
(특정 컨테이너 내에서 bash 쉘을 실행해 상호작용할 수 있는 터미널 세션을 제공)

$ cd /usr/share/nginx/html
특정 컨테이너 내부로 이동 (cd)

$ exit
탈출 !

$ docker container cp '컨테이너 이름':'경로' '저장 위치'
ex) docker container cp nginx-container1:/usr/share/nginx/html/index.html ~/

$ ls -al
현재 세부사항 체크

$ vi '파일 이름 (index.html)'
파일 내용 들어가서 일부 수정하기

$ docker container cp '수정 파일 이름 (~/index.html)' '컨테이너 이름:경로 (nginx-container1:/usr/share/nginx/html/index.html)'
수정된 파일 복사하여 밀어 넣기

[ 볼륨 ]
$ mkdir ~/html
특정 위치의 디렉토리 생성

$ docker run -d --name '컨테이너 이름(nginx-container)' -p '포트 포워딩(9000:80)'
-v '포스트 폴더:컨테이너 폴더(~/html:/usr/share/nginx/html)' '이미지 이름(nginx)'